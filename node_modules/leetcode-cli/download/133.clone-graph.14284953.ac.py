#
# [133] Clone Graph
#
# https://leetcode.com/problems/clone-graph
#
# Medium (25.05%)
# Total Accepted:    99914
# Total Submissions: 398903
# Testcase Example:  '{}'
#
# 
# Clone an undirected graph. Each node in the graph contains a label and a list
# of its neighbors.
# 
# 
# 
# 
# OJ's undirected graph serialization:
# 
# 
# Nodes are labeled uniquely.
# 
# 
# We use # as a separator for each node, and , as a separator for node label
# and each neighbor of the node.
# 
# 
# 
# 
# As an example, consider the serialized graph {0,1,2#1,2#2,2}.
# 
# 
# 
# The graph has a total of three nodes, and therefore contains three parts as
# separated by #.
# 
# First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
# Second node is labeled as 1. Connect node 1 to node 2.
# Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a
# self-cycle.
# 
# 
# 
# 
# Visually, the graph looks like the following:
# 
# 1
# / \
# /   \
# 0 --- 2
# / \
# \_/
# 
# 
# 
# 
#
class Solution:
    # @param node, a undirected graph node
    # @return a undirected graph node
    def cloneGraph(self, node):
        self.cache = {}
        if not node:
            return None
        return self.cloneNode(node)

    def cloneNode(self,n):
        n1=UndirectedGraphNode(n.label)
        self.cache[n.label] = n1
        neighbors = []
        for x in n.neighbors:
            if x.label in self.cache:
                neighbors.append(self.cache[x.label])
            else:
                x1 = self.cloneNode(x)
                neighbors.append(x1)
        n1.neighbors = neighbors
        return n1
