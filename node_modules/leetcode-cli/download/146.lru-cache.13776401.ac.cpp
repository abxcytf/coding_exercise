/*
 * [146] LRU Cache
 *
 * https://leetcode.com/problems/lru-cache
 *
 * Hard (16.50%)
 * Total Accepted:    113863
 * Total Submissions: 689686
 * Testcase Example:  '["LRUCache","put","put","get","put","get","put","get","get","get"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]'
 *
 * 
 * Design and implement a data structure for Least Recently Used (LRU) cache.
 * It should support the following operations: get and put.
 * 
 * 
 * 
 * get(key) - Get the value (will always be positive) of the key if the key
 * exists in the cache, otherwise return -1.
 * put(key, value) - Set or insert the value if the key is not already present.
 * When the cache reached its capacity, it should invalidate the least recently
 * used item before inserting a new item.
 * 
 * 
 * Follow up:
 * Could you do both operations in O(1) time complexity?
 * 
 * Example:
 * 
 * LRUCache cache = new LRUCache( 2 /* capacity */ );
 * 
 * cache.put(1, 1);
 * cache.put(2, 2);
 * cache.get(1);       // returns 1
 * cache.put(3, 3);    // evicts key 2
 * cache.get(2);       // returns -1 (not found)
 * cache.put(4, 4);    // evicts key 1
 * cache.get(1);       // returns -1 (not found)
 * cache.get(3);       // returns 3
 * cache.get(4);       // returns 4
 * 
 * 
 */
struct Node {
    int val;
    int age;
    Node(int v=0,int a=0):val(v),age(a){}
};
class LRUCache{
public:
    LRUCache(int capacity):max(capacity),sz(0),curage(0) {
    }

    int get(int key) {
        map<int,Node>::iterator it = cache.find(key);
        if (it==cache.end()) return -1;

        ++curage;
        int age = it->second.age;
        map<int,int>::iterator it2 = hitmap.find(age);
        hitmap.erase(it2);
        hitmap.insert(pair<int,int>(curage, key));
        it->second.age = curage;
        return it->second.val;
    }

    void set(int key, int value) {
        int v = get(key);
        if (v != -1) {
            cache[key].val = value;
            return;
        }
        if (sz == max) {
            int key = hitmap.begin()->second;
            hitmap.erase(hitmap.begin());
            cache.erase(key);
            --sz;
        }
        ++curage;
        cache[key] = Node(value,curage);
        hitmap.insert(pair<int,int>(curage,key));
        ++sz;
    }

    map<int,Node> cache;
    map<int,int> hitmap;
    int max, sz, curage;
};
